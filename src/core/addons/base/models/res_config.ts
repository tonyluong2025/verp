import _ from "lodash";
import xpath from "xpath/xpath";
import { api, tools } from "../../..";
import { getattr, hasattr } from "../../../api/func";
import { Dict } from "../../../helper/collections";
import { AccessError, NotImplementedError, RedirectWarning, UserError, ValueError } from "../../../helper/errors";
import { BaseModel, MetaModel, TransientModel, _super } from "../../../models";
import { bool } from "../../../tools/bool";
import { isInstance, parseInt, partial, rsplit } from "../../../tools/func";
import { next, sortedAsync } from "../../../tools/iterable";
import { stringify } from "../../../tools/json";
import { repr } from "../../../tools/misc";
import { camelCaseTo_, f } from "../../../tools/utils";
import { serializeXml } from "../../../tools/xml";

class ResConfigModuleInstallationMixin {
  /**
   * Install the requested modules.

    @param modules a list of tuples (moduleName, moduleRecord)
    @returns the next action to execute
   */
  @api.model()
  static async _installModules(self, modules) {
    let toInstallModules = self.env.items('ir.module.module');
    const toInstallMissingNames = [];

    for (const [name, module] of modules) {
      if (!bool(module))
        toInstallMissingNames.push(name);
      else if (await module.state === 'uninstalled')
        toInstallModules = toInstallModules.add(module);
    }
    let result;
    if (toInstallModules.ok)
      result = toInstallModules.buttonImmediateInstall();
    //FIXME: if result is not none, the corresponding todo will be skipped because it was just marked done
    if (toInstallMissingNames) {
      return {
        'type': 'ir.actions.client',
        'tag': 'apps',
        'params': { 'modules': toInstallMissingNames },
      }
    }
    return result;
  }
}

/**
 * Base classes for new-style configuration items

    Configuration items should inherit from this class, implement
    the execute method (and optionally the cancel one) and have
    their view inherit from the related res_config_view_base view.
 */
@MetaModel.define()
class ResConfigConfigurable extends TransientModel {
  static _module = module;
  static _name = 'res.config';
  static _description = 'Config';

  async start() {
    return this.next();
  }

  /**
   * Reload the settings page
   * @returns 
   */
  async next() {
    return {
      'type': 'ir.actions.client',
      'tag': 'reload',
    }
  }

  /**
   * Method called when the user clicks on the ``Next`` button.

      Execute *must* be overloaded unless ``actionNext`` is overloaded
      (which is something you generally don't need to do).

      If ``execute`` returns an action dictionary, that action is executed
      rather than just going to the next configuration item.
   */
  async execute() {
    throw new NotImplementedError('Configuration items need to implement execute');
  }

  /**
   * Method called when the user click on the ``Skip`` button.

      ``cancel`` should be overloaded instead of ``action_skip``. As with
      ``execute``, if it returns an action dictionary that action is
      executed in stead of the default (going to the next configuration item)

      The default implementation is a NOOP.

      ``cancel`` is also called by the default implementation of
      ``actionCancel``.
   */
  async cancel() {
    // pass
  }

  /**
   * Action handler for the ``next`` event.

      Sets the status of the todo the event was sent from to
      ``done``, calls ``execute`` and -- unless ``execute`` returned
      an action dictionary -- executes the action provided by calling
      ``next``.
   * @returns 
   */
  async actionNext() {
    let res: any = await this.execute();
    if (!bool(res)) {
      res = await this.next();
    }
    return res;
  }

  /**
   * Action handler for the ``skip`` event.

      Sets the status of the todo the event was sent from to
      ``skip``, calls ``cancel`` and -- unless ``cancel`` returned
      an action dictionary -- executes the action provided by calling
      ``next``.
   * @returns 
   */
  async actionSkip() {
    let res: any = await this.cancel();
    if (!bool(res)) {
      res = await this.next();
    }
    return res;
  }

  /**
   * Action handler for the ``cancel`` event. That event isn't
      generated by the res.config.view.base inheritable view, the
      inherited view has to overload one of the buttons (or add one
      more).

      Sets the status of the todo the event was sent from to
      ``cancel``, calls ``cancel`` and -- unless ``cancel`` returned
      an action dictionary -- executes the action provided by calling
      ``next``.
   * @returns 
   */
  async actionCancel() {
    let res: any = await this.cancel();
    if (!bool(res)) {
      res = await this.next();
    }
    return res;
  }
}

/**
 * New-style configuration base specialized for addons selection
    and installation.

    Basic usage
    -----------

    Subclasses can simply define a number of boolean fields. The field names
    should be the names of the addons to install (when selected). Upon action
    execution, selected boolean fields (and those only) will be interpreted as
    addons to install, and batch-installed.

    Additional addons
    -----------------

    It is also possible to require the installation of an additional
    addon set when a specific preset of addons has been marked for
    installation (in the basic usage only, additionals can't depend on
    one another).

    These additionals are defined through the ``_installIf``
    property. This property is a mapping of a collection of addons (by
    name) to a collection of addons (by name) [#]_, and if all the *key*
    addons are selected for installation, then the *value* ones will
    be selected as well. For example::

        _installIf = {
            String('sale','crm'): ['sale_crm'],
        }

    This will install the ``sale_crm`` addon if and only if both the
    ``sale`` and ``crm`` addons are selected for installation.

    You can define as many additionals as you wish, and additionals
    can overlap in key and value. For instance::

        _installIf = {
            String('sale','crm'): ['sale_crm'],
            String('sale','project'): ['sale_service'],
        }

    will install both ``sale_crm`` and ``sale_service`` if all of
    ``sale``, ``crm`` and ``project`` are selected for installation.

    Hook methods
    ------------

    Subclasses might also need to express dependencies more complex
    than that provided by additionals. In this case, it's possible to
    define methods of the form ``_if_%(name)s`` where ``name`` is the
    name of a boolean field. If the field is selected, then the
    corresponding module will be marked for installation *and* the
    hook method will be executed.

    Hook methods take the usual set of parameters (cr, uid, ids,
    context) and can return a collection of additional addons to
    install (if they return anything, otherwise they should not return
    anything, though returning any "falsy" value such as None or an
    empty collection will have the same effect).

    Complete control
    ----------------

    The last hook is to simply overload the ``modules_to_install``
    method, which implements all the mechanisms above. This method
    takes the usual set of parameters (cr, uid, ids, context) and
    returns a ``set`` of addons to install (addons selected by the
    above methods minus addons from the *basic* set which are already
    installed) [#]_ so an overloader can simply manipulate the ``set``
    returned by ``ResConfigInstaller.modules_to_install`` to add or
    remove addons.

    Skipping the installer
    ----------------------

    Unless it is removed from the view, installers have a *skip*
    button which invokes ``action_skip`` (and the ``cancel`` hook from
    ``res.config``). Hooks and additionals *are not run* when skipping
    installation, even for already installed addons.

    Again, setup your hooks accordingly.

    .. [#] note that since a mapping key needs to be hashable, it's
           possible to use a tuple or a frozenset, but not a list or a
           regular set

    .. [#] because the already-installed modules are only pruned at
           the very end of ``modulesToInstall``, additionals and
           hooks depending on them *are guaranteed to execute*. Setup
           your hooks accordingly.
 */
@MetaModel.define()
class ResConfigInstaller extends TransientModel implements ResConfigModuleInstallationMixin {
  static _module = module;
  static _name = 'res.config.installer';
  static _parents = 'res.config';
  static _description = 'Config Installer';

  static _installIf = {};

  static async _installModules(self: any, modules: any): Promise<any> {
    return ResConfigModuleInstallationMixin._installModules(self, modules);
  }

  /**
   * For each module, check if it's already installed and if it
    is return its name

    @returns a list of the already installed modules in this
              installer
   */
  async alreadyInstalled(): Promise<string[]> {
    const res = [];
    for (const m of await this._alreadyInstalled()) {
      res.push(await m.label);
    }
    return res;
  }

  /**
   * For each module (boolean fields in a res.config.installer),
        check if it's already installed (either 'to install', 'to upgrade'
        or 'installed') and if it is return the module's record

      @returns a list of all installed modules in this installer
   */
  async _alreadyInstalled() {
    const selectable = [];
    for (const [name, field] of this._fields.items()) {
      if (field.type === 'boolean') {
        selectable.push(name);
      }
    }
    return this.env.items('ir.module.module').search([['label', 'in', selectable], ['state', 'in', ['to install', 'installed', 'to upgrade']]]);
  }

  /**
   * selects all modules to install:

    * checked boolean fields
    * return values of hook methods. Hook methods are of the form
      ``_if_%(addonName)s``, and are called if the corresponding
      addon is marked for installation. They take the arguments
      cr, uid, ids and context, and return an iterable of addon
      names
    * additionals, additionals are setup through the ``_installIf``
      class variable. ``_installIf`` is a dict of {iterable:iterable}
      where key and value are iterables of addon names.

      If all the addons in the key are selected for installation
      (warning: addons added through hooks don't count), then the
      addons in the value are added to the set of modules to install
    * not already installed
   */
  async modulesToInstall() {
    const base = new Set();
    for (const installer of await this.read()) {
      for (const [moduleName, toInstall] of Object.entries<any>(installer)) {
        if (this._fields[moduleName].type === 'boolean' && toInstall) {
          base.add(moduleName);
        }
      }
    }
    const hooksResults = new Set();
    for (const module of base) {
      const hook = this[`_if_${module}`] ?? null;
      if (hook) {
        (hook() ?? new Set()).forEach(h => { if (!hooksResults.has(h)) hooksResults.add(h) });
      }
    }
    const isSuperset = (set, subset) => {
      for (const elem of subset) {
        if (!set.has(elem)) {
          return false;
        }
      }
      return true;
    }

    const additionals = new Set();
    module
    for (const [requirements, consequences] of Object.entries<any>(this.cls._installIf)) {
      if (isSuperset(base, requirements)) {
        for (const module of consequences) {
          additionals.add(module);
        }
      }
    }

    return _.difference(_.union(Array.from(base), Array.from(hooksResults), Array.from(additionals)), await this.alreadyInstalled());
  }

  /**
   * If an addon is already installed, check it by default
   * @param fieldsList 
   * @returns 
   */
  @api.model()
  async defaultGet(fieldsList) {
    const defaults = await _super(ResConfigInstaller, this).defaultGet(fieldsList);
    return { ...defaults, ...Dict.fromKeys(await this.alreadyInstalled(), true) };
  }

  @api.model()
  async fieldsGet(allfields?: any, attributes?: any) {
    console.log('res.config fieldGet');
    const res = await _super(ResConfigInstaller, this).fieldsGet(allfields, attributes);
    for (const name of await this.alreadyInstalled()) {
      if (!(name in res)) {
        continue;
      }
      Object.assign(res[name], {
        readonly: true, help: (res[name]['help'] || '') +
          await this._t('\n\nThis addon is already installed on your system')
      })
    }
    return res;
  }

  async execute() {
    const toInstall = Array.from(await this.modulesToInstall());
    console.info('Selecting addons %s to install', toInstall);

    const IrModule = this.env.items('ir.module.module');
    const modules = [];
    for (const name of toInstall) {
      const module = await IrModule.search([['label', '=', name]], { limit: 1 });
      modules.push([name, module]);
    }
    return ResConfigInstaller._installModules(this, modules);

  }
}

/**
 * Base configuration wizard for application settings.  It provides support for setting
        default values, assigning groups to employee users, and installing modules.
        To make such a 'settings' wizard, define a model like::

            class MyConfigWizard extends TransientModel {
                static _module = module;
                static _name = 'my.settings'
                static _parents = 'res.config.settings'

                static defaultFoo = Fields.type(..., {defaultModel: 'my.model'}),
                static groupBar = Fields.Boolean(..., {group: 'base.groupUser', impliedGroup: 'my.group'}),
                static moduleBaz = Fields.Boolean(...),
                static configQux = Fields.Char(..., {configParameter: 'my.parameter'})
                static otherField = Fields.type(...),
            }

        The method ``execute`` provides some support based on a naming convention:

        *   For a field like 'default_XXX', ``execute`` sets the (global) default value of
            the field 'XXX' in the model named by ``defaultModel`` to the field's value.

        *   For a boolean field like 'groupXXX', ``execute`` adds/removes 'implied_group'
            to/from the implied groups of 'group', depending on the field's value.
            By default 'group' is the group Employee.  Groups are given by their xml id.
            The attribute 'group' may contain several xml ids, separated by commas.

        *   For a selection field like 'groupXXX' composed of 2 string values ('0' and '1'),
            ``execute`` adds/removes 'implied_group' to/from the implied groups of 'group', 
            depending on the field's value.
            By default 'group' is the group Employee.  Groups are given by their xml id.
            The attribute 'group' may contain several xml ids, separated by commas.

        *   For a boolean field like 'moduleXXX', ``execute`` triggers the immediate
            installation of the module named 'XXX' if the field has value ``true``.

        *   For a selection field like 'moduleXXX' composed of 2 string values ('0' and '1'), 
            ``execute`` triggers the immediate installation of the module named 'XXX' 
            if the field has the value ``'1'``.

        *   For a field with no specific prefix BUT an attribute 'configParameter',
            ``execute``` will save its value in an ir.config.parameter (global setting for the
            database).

        *   For the other fields, the method ``execute`` invokes `set_values`.
            Override it to implement the effect of those fields.

        The method ``defaultGet`` retrieves values that reflect the current status of the
        fields like 'default_XXX', 'groupXXX', 'moduleXXX' and configXXX.
        It also invokes all methods with a name that starts with 'getDefault';
        such methods can be defined to provide current values for other fields.
 */
@MetaModel.define()
class ResConfigSettings extends TransientModel implements ResConfigModuleInstallationMixin {
  static _module = module;
  static _name = 'res.config.settings';
  static _description = 'Config Settings';

  static async _installModules(self: any, modules: any): Promise<any> {
    return ResConfigModuleInstallationMixin._installModules(self, modules);
  }

  _validFieldParameter(field, name) {
    return (
      ['defaultModel', 'configParameter'].includes(name)
      || ['boolean', 'selection'].includes(field.type) && ['group', 'impliedGroup'].includes(name)
      || _super(ResConfigSettings, this)._validFieldParameter(field, name)
    )
  }

  async copy(values) {
    throw new UserError(await this._t("Cannot duplicate configuration!"), "");
  }

  @api.model()
  async fieldsViewGet(viewId?: any, viewType: string = 'form', toolbar: boolean = false, submenu: boolean = false) {
    const retVal = await _super(ResConfigSettings, this).fieldsViewGet(viewId, viewType, toolbar, submenu);

    const canInstallModules = await this.env.items('ir.module.module').checkAccessRights('write', false);

    const doc = retVal['dom'];

    for (const field of Object.keys(retVal['fields'])) {
      if (!field.startsWith("module")) {
        continue;
      }
      const nodes: any[] = xpath.select(f('//field[@name="%s"]', field), doc) ?? [];
      for (const node of nodes) {
        if (!canInstallModules) {
          node.setAttribute("readonly", "1");
          const modifiers = JSON.parse(node.get("modifiers"));
          modifiers['readonly'] = true;
          node.setAttribute("modifiers", stringify(modifiers));
        }
      }
    }
    retVal['arch'] = serializeXml(doc);
    return retVal;
  }

  async onchangeModule(fieldValue, moduleName) {
    const ModuleSudo = await this.env.items('ir.module.module').sudo();
    const modules = await ModuleSudo.search(
      [['label', '=', camelCaseTo_(moduleName.slice(6))],
      ['state', 'in', ['to install', 'installed', 'to upgrade']]]);

    if (modules.ok && !parseInt(fieldValue)) {
      const deps = await (await modules.sudo()).downstreamDependencies();
      const depNames = await deps.or(modules).mapped('shortdesc');
      const message = depNames.join('\n');
      return {
        'warning': {
          'title': await this._t('Warning!'),
          'message': await this._t('Disabling this option will also uninstall the following modules \n%s', message),
        }
      }
    }
    return {};
  }

  /**
   * Add an onchange method for each module field.
   * @returns 
   */
  async _registerHook() {
    async function makeMethod(field) {
      return async (self) => self.onchangeModule(await self[field], field);
    }

    for (const field of this._fields.keys()) {
      if (field.startsWith('module')) {
        const onchangeMethods = this.cls._onchangeMethods();
        onchangeMethods[field] = onchangeMethods[field] ?? [];
        onchangeMethods[field].push(await makeMethod(field));
      }
    }
  }

  /**
   * return a dictionary with the fields classified by category:
      { 'default': [['defaultFoo', 'model', 'foo'], ...],
        'group':   [['groupBar', [browseGroup], browseImpliedGroup), ...],
        'module':  [['moduleBaz', browseModule], ...'],
        'config':  [['configQux', 'my.parameter'], ...],
        'other':   ['otherField', ...],
      }
   */
  @api.model()
  async _getClassifiedFields() {
    const IrModule = await this.env.items('ir.module.module').sudo();
    const Groups = this.env.items('res.groups');

    const defaults = [], groups = [], modules = [], configs = [], others = [];
    for (const [name, field] of this._fields) {
      if (name.startsWith('default')) {
        if (!hasattr(field, 'defaultModel')) {
          throw new ValueError("Field %s without attribute 'defaultModel'", field);
        }
        defaults.push([name, field.defaultModel, _.lowerFirst(name.slice(7))]); // defaultProductTemplateId => productTemplateId 
      }
      else if (name.startsWith('group')) {
        if (!['boolean', 'selection'].includes(field.type)) {
          throw new ValueError("Field %s must have type 'boolean' or 'selection'", field);
        }
        if (!hasattr(field, 'impliedGroup')) {
          throw new ValueError("Field %s without attribute 'impliedGroup'", field);
        }
        const fieldGroupXmlids = getattr(field, 'group', 'base.groupUser').split(',');
        const fieldGroups = Groups.concat(await Promise.all(fieldGroupXmlids.map(async (it) => this.env.ref(it))));
        groups.push([name, fieldGroups, await this.env.ref(field.impliedGroup)]);
      }
      else if (name.startsWith('module')) {
        if (!['boolean', 'selection'].includes(field.type)) {
          throw new ValueError("Field %s must have type 'boolean' or 'selection'", field);
        }
        const module = await IrModule.search([['label', '=', camelCaseTo_(name.slice(6))]], { limit: 1 }); // 'moduleAccountAnalytic' => 'account_analytic' 
        modules.push([name, module]);
      }
      else if (hasattr(field, 'configParameter')) {
        if (!['boolean', 'integer', 'float', 'char', 'selection', 'many2one', 'datetime'].includes(field.type)) {
          throw new ValueError("Field %s must have type 'boolean', 'integer', 'float', 'char', 'selection', 'many2one' or 'datetime'", field);
        }
        configs.push([name, field.configParameter]);
      }
      else {
        others.push(name);
      }
    }
    return { 'default': defaults, 'group': groups, 'module': modules, 'config': configs, 'other': others }
  }

  /**
   * Return values for the fields other that `default`, `group` and `module`

   * @returns 
   */
  async getValues() {
    return {};
  }

  /**
   * Set values for the fields other that `default`, `group` and `module`

   */
  async setValues() {
    const self = await this.withContext({ activeTest: false });
    const classified = await self._getClassifiedFields();

    // default values fields
    const IrDefault = await self.env.items('ir.default').sudo();
    for (const [name, model, field] of classified['default']) {
      let value;
      const subField = await self[name];
      if (isInstance(subField, BaseModel)) {
        if (self._fields[name].type === 'many2one') {
          value = subField.id;
        }
        else {
          value = subField.ids;
        }
      }
      else {
        value = subField;
      }
      await IrDefault.setDefault(model, field, value);
    }
    // group fields: modify group / implied groups
    const currentSettings = await self.defaultGet(Object.keys(await self.fieldsGet()));
    // with self.env.noRecompute():
    {
      for (let [name, groups, impliedGroup] of await sortedAsync(classified['group'], async (k) => self[k[0]])) {
        groups = await groups.sudo();
        impliedGroup = await impliedGroup.sudo();
        const value = await self[name];
        if (value === currentSettings[name]) {
          continue;
        }
        if (tools.parseInt(value)) {
          await groups._applyGroup(impliedGroup);
        }
        else {
          await groups._removeGroup(impliedGroup);
        }
      }
    }
    // config fields: store ir.config.parameters
    const IrConfigParameter = await self.env.items('ir.config.parameter').sudo();
    for (const [name, icp] of classified['config']) {
      const field = self._fields[name];
      let value = await self[name];
      if (field.type === 'char') {
        // storing developer keys as ir.config.parameter may lead to nasty bugs when users leave spaces around them
        // console.log('value', typeof value, value);
        value = (value || "").trim() || false;
      }
      else if (['integer', 'float'].includes(field.type)) {
        value = bool(value) ? repr(value) : false;
      }
      else if (field.type === 'many2one') {
        // value is a (possibly empty) recordset
        value = value.id;
      }
      await IrConfigParameter.setParam(icp, value);
    }
  }

  @api.model()
  async defaultGet(fields) {
    const IrDefault = this.env.items('ir.default');
    const IrConfigParameter = await this.env.items('ir.config.parameter').sudo();
    const classified = await this._getClassifiedFields();

    const res = await _super(ResConfigSettings, this).defaultGet(fields);

    // defaults: take the corresponding default value they set
    for (const [name, model, field] of classified['default']) {
      const value = await IrDefault.get(model, field);
      if (value != null) {
        res[name] = value;
      }
    }

    // groups: which groups are implied by the group Employee
    for (const [name, groups, impliedGroup] of classified['group']) {
      res[name] = await groups.all(async (group) => (await group.impliedIds).includes(impliedGroup));
      if (this._fields[name].type === 'selection') {
        res[name] = String(parseInt(res[name]))     // true, false -> '1', '0'
      }
    }
    // modules: which modules are installed/to install
    for (const [name, module] of classified['module']) {
      res[name] = ['installed', 'to install', 'to upgrade'].includes(await module.state);
      if (this._fields[name].type === 'selection') {
        res[name] = String(parseInt(res[name]))     // true, false -> '1', '0'
      }
    }

    // config: get & convert stored ir.configParameter (or default)
    const WARNING_MESSAGE = "Error when converting value %s of field %s for ir.config.parameter %s"
    for (const [name, icp] of classified['config']) {
      const field = this._fields[name];
      let value = await IrConfigParameter.getParam(icp, field.default ? await field.default(this) : false);
      if (value != false) {
        if (field.type === 'many2one') {
          try {
            // Special case when value is the id of a deleted record, we do not want to block the settings screen
            value = (await this.env.items(field.comodelName).browse(parseInt(value)).exists()).id;
          } catch (e) {
            console.warn(WARNING_MESSAGE, value, field, icp)
            value = false;
          }
        }
        else if (field.type === 'integer') {
          try {
            value = parseInt(value);
          } catch (e) {
            console.warn(WARNING_MESSAGE, value, field, icp);
            value = 0;
          }
        }
        else if (field.type === 'float') {
          try {
            value = parseFloat(value);
          } catch (e) {
            console.warn(WARNING_MESSAGE, value, field, icp);
            value = 0.0;
          }
        }
        else if (field.type === 'boolean') {
          value = bool(value);
        }
      }
      res[name] = value;
    }
    Object.assign(res, await this.getValues());

    return res;
  }

  /**
   * Called when settings are saved.

    This method will call `setValues` and will install/uninstall any modules defined by
    `module` Boolean fields and then trigger a web client reload.

    .. warning::

        This method **SHOULD NOT** be overridden, in most cases what you want to override is
        `~setValues()` since `~execute()` does little more than simply call `~setValues()`.

        The part that installs/uninstalls modules **MUST ALWAYS** be at the end of the
        transaction, otherwise there's a big risk of registry <-> database desynchronisation.

   */
  async execute() {
    this.ensureOne();
    if (! await this.env.isAdmin()) {
      throw new AccessError(await this._t("Only administrators can change the settings"));
    }

    let self = await this.withContext({ activeTest: false });
    const classified = await self._getClassifiedFields();

    await self.setValues();

    // module fields: install/uninstall the selected modules
    const toInstall = [];
    const toUninstallModules = self.env.items('ir.module.module');
    for (const [name, module] of classified['module']) {
      if (parseInt(await self[name])) {
        toInstall.push([camelCaseTo_(name.slice(6)), module]);
      }
      else {
        if (bool(module) && ['installed', 'to upgrade'].includes(await module.state)) {
          toUninstallModules.add(module);
        }
      }
    }
    if (bool(toInstall) || bool(toUninstallModules)) {
      await self.flush();
    }

    if (bool(toUninstallModules)) {
      await toUninstallModules.buttonImmediateUninstall();
    }

    const installationStatus = await self.cls._installModules(self, toInstall);

    if (bool(installationStatus) || bool(toUninstallModules)) {
      // After the uninstall/install calls, the registry and environments are no longer valid. So we reset the environment.
      await self.env.reset();
      self = (await self.env.change()).items(self._name);
    }

    const config = await self.env.items('res.config').next() ?? {};
    if (!['ir.actions.actwindow.close',].includes(config['type'])) {
      return config;
    }

    // force client-side reload (update user menu and current view)
    return {
      'type': 'ir.actions.client',
      'tag': 'reload',
    }
  }

  async cancel() {
    // ignore the current record, and send the action to reopen the view
    const actions = await this.env.items('ir.actions.actwindow').search([['resModel', '=', this._name]], { limit: 1 });
    if (actions.ok) {
      return actions.readOne();
    }
    return {};
  }

  /**
   * Override nameGet method to return an appropriate configuration wizard
    name, and not the generated name.
   * @returns 
   */
  async nameGet() {
    const action = await this.env.items('ir.actions.actwindow').search([['resModel', '=', this._name]], { limit: 1 });
    const name = await action.label || this._name;
    const res = []
    for (const record of this) {
      res.push([record.id, name]);
    }
    return res;
  }

  /**
   *     Fetch the path to a specified configuration view and the action id to access it.

    @param menuXmlid the xml id of the menuitem where the view is located,
        structured as follows: module_name.menuitemXmlid (e.g.: "sales_team.menuSaleConfig")
    @returns tuple
        - t[0]: string: full path to the menuitem (e.g.: "Settings/Configuration/Sales")
        - t[1]: integer or long: id of the menuitem's action

   * @param menuXmlid 
   * @returns 
   */
  @api.model()
  async getOptionPath(menuXmlid) {
    const irUiMenu = await this.env.ref(menuXmlid);
    return [await irUiMenu.completeName, (await irUiMenu.action).id];
  }

  /**
   * Fetch the human readable name of a specified configuration option.

    @param fullFieldName the full name of the field, structured as follows:
            modelName.fieldName (e.g.: "sale.config.settings.fetchmailLead")
    @returns human readable name of the field (e.g.: "Create leads from incoming mails")
   */
  @api.model()
  async getOptionName(fullFieldName) {
    const [modelName, fieldName] = rsplit(fullFieldName, '.', 1);
    return (await this.env.items(modelName).fieldsGet([fieldName]))[fieldName]['string'];
  }

  /**
   * Helper: return a Warning exception with the given message where the %(field:xxx)s
    and/or %(menu:yyy)s are replaced by the human readable field's name and/or menuitem's
    full path.

    Usage:
    ------
    Just include in your error message %(field:modelName.fieldName)s to obtain the human
    readable field's name, and/or %(menu:module_name.menuitemXmlid)s to obtain the menuitem's
    full path.

    Example of use:
    ---------------
    from core.addons.base.models.res_config import get_warning_config
    raise get_warning_config(cr, await this._t("Error: this action is prohibited. You should check the field %(field:sale.config.settings.fetchmail_lead)s in %(menu:sales_team.menuSaleConfig)s."), context=context)

    This will return an exception containing the following message:
        Error: this action is prohibited. You should check the field Create leads from incoming mails in Settings/Configuration/Sales.

    What if there is another substitution in the message already?
    -------------------------------------------------------------
    You could have a situation where the error message you want to upgrade already contains a substitution. Example:
        Cannot find any account journal of %s type for this company.\n\nYou can create one in the menu: \nConfiguration\Journals\Journals.
    What you want to do here is simply to replace the path by %menu:account.menuAccountConfig)s, and leave the rest alone.
    In order to do that, you can use the double percent (%%) to escape your new substitution, like so:
        Cannot find any account journal of %s type for this company.\n\nYou can create one in the %%(menu:account.menuAccountConfig)s.
   * @param msg 
   * @returns 
   */
  @api.model()
  async getConfigWarning(msg: string) {
    const self = await this.sudo();

    // Process the message
    // 1/ find the menu and/or field references, put them in a list
    const regexPath = /%\(((?:menu|field):[a-z_\.]*)\)s/gi;
    const references = msg.match(regexPath);

    // 2/ fetch the menu and/or field replacement values (full path and
    //    human readable field's name) and the actionId if any
    const values = {};
    let actionId;
    for (const item of references) {
      const [refType, ref] = item.split(':');
      if (refType === 'menu') {
        [values[item], actionId] = await self.getOptionPath(ref);
      }
      else if (refType === 'field') {
        values[item] = await self.getOptionName(ref);;
      }
    }
    // 3/ substitute and return the result
    if (bool(actionId)) {
      return new RedirectWarning(msg, values, actionId, await this._t('Go to the configuration panel'));
    }
    return new UserError(msg, values);
  }

  @api.model()
  async create(values) {
    // Optimisation: saving a res.config.settings even without changing any values will trigger the write of all related values. This in turn may trigger chain of further recomputation. To avoid it, delete values that were not changed.
    for (const field of this._fields.values()) {
      if (!(field.name in values && field.related && !field.readonly)) {
        continue;
      }
      // we write on a related field like
      // qr_code = Fields.Boolean(related='companyId.qr_code', readonly=false)
      const [fname0, ...fnames] = field.related.split(".");
      if (!(fname0 in values)) {
        continue;
      }

      // determine the current value
      const field0 = this._fields[fname0];
      let oldValue = await field0.convertToRecord(
        await field0.convertToCache(values[fname0], this), this);
      for (const fname of fnames) {
        oldValue = next(oldValue, oldValue)[fname];
      }
      // determine the new value
      const newValue = await field.convertToRecord(
        await field.convertToCache(values[field.name], this), this);

      // drop if the value is the same
      if (oldValue === newValue) {
        values.pop(field.name);
      }
    }
    return _super(ResConfigSettings, this).create(values);
  }
}