import { Fields } from "../../../core";
import { MetaModel, Model } from "../../../core/models"

@MetaModel.define()
class UtmCampaign extends Model {
    static _module = module;
    static _parents = 'utm.campaign';
    static _description = 'UTM Campaign';

    static quotationCount = Fields.Integer('Quotation Count', {groups: 'sales_team.groupSaleSalesman', compute: "_computeQuotationCount"});
    static invoicedAmount = Fields.Integer({default: 0, compute: "_computeSaleInvoicedAmount", string: "Revenues generated by the campaign"});
    static companyId = Fields.Many2one('res.company', {string: 'Company', readonly: true, states: {'draft': [['readonly', false]], 'refused': [['readonly', false]]}, default: self => self.env.company()});
    static currencyId = Fields.Many2one('res.currency', {related: 'companyId.currencyId', string: 'Currency'});

    async _computeQuotationCount() {
        const quotationData = await this.env.items('sale.order').readGroup([
            ['campaignId', 'in', this.ids]],
            ['campaignId'], ['campaignId']);
        const dataMap = {}
        for (const datum of quotationData) {
            dataMap[datum['campaignId'][0]] = datum['campaignId_count'];
        }
        for (const campaign of this) {
            await campaign.set('quotationCount', dataMap[campaign.id] ?? 0);
        }
    }

    async _computeSaleInvoicedAmount() {
        await this.env.items('account.move.line').flush(['balance', 'moveId', 'accountId', 'excludeFromInvoiceTab']);
        await this.env.items('account.move').flush(['state', 'campaignId', 'moveType']);
        const query = `SELECT move."campaignId", -SUM(line.balance) as "priceSubtotal"
                    FROM "accountMoveLine" line
                    INNER JOIN "accountMove" move ON line."moveId" = move.id
                    WHERE move.state not in ('draft', 'cancel')
                        AND move."campaignId" IN (%s)
                        AND move."moveType" IN ('outInvoice', 'outRefund', 'inInvoice', 'inRefund', 'outReceipt', 'inReceipt')
                        AND line."accountId" IS NOT NULL
                        AND NOT line."excludeFromInvoiceTab"
                    GROUP BY move."campaignId"
                    `;

        const res = await this._cr.execute(query, [String(this.ids) || 'NULL']);

        let campaigns = this.browse();
        for (const datum of res) {
            const campaign = this.browse(datum['campaignId']);
            await campaign.set('invoicedAmount', datum['priceSubtotal']);
            campaigns = campaigns.or(campaign);
        }
        for (const campaign of this.sub(campaigns)) {
            await campaign.set('invoicedAmount', 0);
        }
    }

    async actionRedirectToQuotations() {
        const action = await this.env.items("ir.actions.actions")._forXmlid("sale.actionQuotationsWithOnboarding");
        action['domain'] = [['campaignId', '=', this.id]];
        action['context'] = {'default_campaignId': this.id}
        return action;
    }

    async actionRedirectToInvoiced() {
        const action = await this.env.items("ir.actions.actions")._forXmlid("account.actionMoveJournalLine");
        const invoices = await this.env.items('account.move').search([['campaignId', '=', this.id]]);
        action['context'] = {
            'create': false,
            'edit': false,
            'viewNoMaturity': true
        }
        action['domain'] = [
            ['id', 'in', invoices.ids],
            ['moveType', 'in', ['outInvoice', 'outRefund', 'inInvoice', 'inRefund', 'outReceipt', 'inReceipt']],
            ['state', 'not in', ['draft', 'cancel']]
        ]
        return action;
    }
}
