import _ from "lodash"
import { Fields, api } from "../../../core"
import { MetaModel, TransientModel, _super } from "../../../core/models"
import { f } from "../../../core/tools/utils"
import { bool } from "../../../core/tools/bool"

@MetaModel.define()
class MailTemplatePreview extends TransientModel {
  static _module = module;
  static _name = 'mail.template.preview';
  static _description = 'Email Template Preview';
  _MAIL_TEMPLATE_FIELDS = ['subject', 'bodyHtml', 'emailFrom', 'emailTo', 'emailCc', 'replyTo', 'scheduledDate', 'attachmentIds']

  @api.model()
  async _selectionTargetModel() {
    const res = [];
    for (const model of await (await this.env.items('ir.model').sudo()).search([])) {
      res.push(await model('model', 'label'));
    }
    return res;
  }

  @api.model()
  async _selectionLanguages() {
    return this.env.items('res.lang').getInstalled();
  }

  @api.model()
  async defaultGet(fields) {
    const result = await _super(MailTemplatePreview, this).defaultGet(fields);
    if (! result['mailTemplateId'] || !fields.includes('resourceRef')) {
      return result;
    }
    const mailTemplate = await this.env.items('mail.template').browse(result['mailTemplateId']).sudo();
    const model = await mailTemplate.model;
    const res = await this.env.items(model).search([], {limit: 1});
    if (res.ok) {
      result['resourceRef'] = f('%s,%s', model, res.id);
    }
    return result;
  }

  static mailTemplateId = Fields.Many2one('mail.template', {string: 'Related Mail Template', required: true})
  static modelId = Fields.Many2one('ir.model', {string: 'Targeted model', related: "mailTemplateId.modelId"})
  static resourceRef = Fields.Reference('_selectionTargetModel', {string: 'Record'})
  static lang = Fields.Selection(async (self) => self._selectionLanguages(), {string: 'Template Preview Language'})
  static noRecord = Fields.Boolean('No Record', {compute: '_computeNoRecord'})
  static errorMsg = Fields.Char('Error Message', {readonly: true})
  // Fields same than the mail.template model, computed with resourceRef and lang
  static subject = Fields.Char('Subject', {compute: '_computeMailTemplateFields'})
  static emailFrom = Fields.Char('From', {compute: '_computeMailTemplateFields', help: "Sender address"})
  static emailTo = Fields.Char('To', {compute: '_computeMailTemplateFields', help: "Comma-separated recipient addresses"})
  static emailCc = Fields.Char('Cc', {compute: '_computeMailTemplateFields', help: "Carbon copy recipients"})
  static replyTo = Fields.Char('Reply-To', {compute: '_computeMailTemplateFields', help: "Preferred response address"})
  static scheduledDate = Fields.Char('Scheduled Date', {compute: '_computeMailTemplateFields', help: "The queue manager will send the email after the date"})
  static bodyHtml = Fields.Html('Body', {compute: '_computeMailTemplateFields', sanitize: false})
  static attachmentIds = Fields.Many2many('ir.attachment', {string: 'Attachments', compute: '_computeMailTemplateFields'})
  // Extra fields info generated by generate_email
  static partnerIds = Fields.Many2many('res.partner', {string: 'Recipients', compute: '_computeMailTemplateFields'})

  @api.depends('modelId')
  async _computeNoRecord() {
    for (const [preview, previewSudo] of _.zip([...this], [...(await this.sudo())])) {
      const modelId = await previewSudo.modelId;
      await preview.set('noRecord', ! bool(modelId) || ! await this.env.items(await modelId.model).searchCount([]));
    }
  }

  /**
   * Preview the mail template (body, subject, ...) depending of the language and
    the record reference, more precisely the record id for the defined model of the mail template.
    If no record id is selectable/set, the inline_template placeholders won't be replace in the display information.
   */
  @api.depends('lang', 'resourceRef')
  async _computeMailTemplateFields() {
    const self: any = this;
    const lang = await self.lang;
    const copyDependsValues = {'lang': lang}
    const mailTemplate = await (await self.mailTemplateId).withContext({lang: lang});
    const resourceRef = await self.resourceRef;
    try {
      if (! resourceRef) {
        await self._setMailAttributes();
      }
      else {
        copyDependsValues['resourceRef'] = f('%s,%s', resourceRef._name, resourceRef.id)
        const mailValues = await (await mailTemplate.withContext({templatePreviewLang: lang})).generateEmail(
          resourceRef.id, self._MAIL_TEMPLATE_FIELDS);
        self._setMailAttributes(mailValues);
      }
      await self.set('errorMsg', false);
    } catch(e) {
    // except UserError as user_error:
      await self._setMailAttributes();
      await self.set('errorMsg', e.message);
    }
    finally {
      // Avoid to be change by a invalidate_cache call (in generate_mail), e.g. Quotation / Order report
      await self.update(copyDependsValues);
    }
  }

  async _setMailAttributes(values?: any) {
    for (const field of this._MAIL_TEMPLATE_FIELDS) {
      const fieldValue = values ? values[field] ?? false : await (await (this as any).mailTemplateId)[field];
      await this.set(field, fieldValue)
    }
    await this.set('partnerIds', values ? values['partnerIds'] ?? false : false);
  }
}